# -*- coding: utf-8 -*-"""Created on Thu Aug 13 11:07:21 2020@author: Rae"""import cv2import numpy as npimport matplotlib.pyplot as pltimport matplotlib as mplfrom cycler import cyclerimport sysimport time"""    load files+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"""# filename defined here - will read in laterfilename1='../20221129-162321.h264'#fileName=sys.argv[1]filename2 = filename1[0:-5]"""-------------------------------------------------------------------------------""""""    get 500th frame from video and plot as jpg+++++++++++++++++++++++++++++++++"""vidcap = cv2.VideoCapture(filename1)count = 0success = Trueprint('First frame read')print('Read first 500 frames')while success:    success,image = vidcap.read()    if count == 100:        cv2.imwrite(filename2+'_frame1.jpg',image)        break    count+=1print('...done')"""-------------------------------------------------------------------------------""""""    load firstframe, convert to grayscale and blur+++++++++++++++++++++++++++++"""# Load in image here - Ensure 8-bit grayscale#img1 = cv2.imread(filename2+'_frame1.jpg',cv2.IMREAD_GRAYSCALE) img1=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)square_scale=np.mean(img1[-100:-1,-100:-1])#img1 = cv2.blur(img1, (3, 3))#img = cv2.filter2D(img1,-1, np.ones((5,5),np.float32)/25)img = cv2.GaussianBlur(img1,(7,7),0)# size of the imageH, W = img.shape"""-------------------------------------------------------------------------------""""""    determine position of drops+++++++++++++++++++++++++++++++++++++++++++++++"""# Stores the final circles that don't go out of boundsfinal_circles = [] # If detection of circles not correct can change variables in following line:circles	= cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,3,\                        100,param1=110,param2=50,minRadius=25,maxRadius=55)#circles	= np.uint16(np.around(circles))# Convert to integercircles = np.round(circles[0, :]).astype("int") """-------------------------------------------------------------------------------"""# Obtain rows and columnsrows = H cols = Wfor (x, y, r) in circles: # For each circle we have detected...    if (600<= x <= cols-500) and ( 110 <= y <= rows-200): # Check if circle is within boundary        final_circles.append([x, y, r]) # If it is, add this to our final list# Convert to numpy array for compatabilityfinal_circles = np.asarray(final_circles).astype("int") img=imagefor i in final_circles:        # draw	the	outer	circle	cv2.circle(img,(i[0],i[1]),i[2],(0,255,0),2)	# draw	the	center	of	the	circle	cv2.circle(img,(i[0],i[1]),2,(0,0,255),3)cv2.imshow("HoughCirlces", img)cv2.waitKey()cv2.destroyAllWindows()"""    Ae position of drops successfully determined? If not go back to line 55 and change variables"""user_input= input('Continue?')if user_input == 'n':    sys.exit()  mask = np.zeros(img.shape, np.uint8)# number of circlesd_total =  np.ndarray.item(np.array(final_circles.shape[0:1]))"""    read video as frames and calculate std"""results, frame_count = [], []vidcap = cv2.VideoCapture(filename1)success,frame = vidcap.read()count=0while success:    print('Read a new frame: ', success, count)    success,frame = vidcap.read()    if(not success):        break    count += 1        roi = np.zeros(frame.shape[:2], np.uint8)    border=1    height, width = img1.shape    for i in final_circles:        x,y,r = i[0], i[1], i[2]        # writes the circle onto the roi mask        roi = cv2.circle(roi, (x, y), r, 255, cv2.FILLED)        mask = np.ones_like(frame) * 255        # this gets the part of the image masked by roi and puts on mask        mask = cv2.bitwise_and(mask, frame, mask=roi) + cv2.bitwise_and(mask, mask, mask=~roi)        x1 = max(x-r - border//2, 0)      # eventually  -(border//2+1)        x2 = min(x+r + border//2, width)  # eventually  +(border//2+1)        y1 = max(y-r - border//2, 0)      # eventually  -(border//2+1)        y2 = min(y+r + border//2, height) # eventually  +(bord        # get the part of the image that corresponds to the drop        image = mask[y1:y2,x1:x2]        # cv2.imshow('b', image)         square_scale1=np.mean(image[-100:-1,-100:-1])        std=np.nanstd(image*square_scale/square_scale1)        # print(std)        # cntNotBlack = cv2.countNonZero(image)        results.append(std)        frame_count.append(count)"""    Convert to lists to array and save data"""frame_count = np.array(frame_count)results = np.array(results)f_total = np.ndarray.item(np.array(frame_count[-1:]))x = frame_count[::d_total]# put into 2-d array of points. Can access with e.g. plt.plot(np.array(l)[:,14])l = np.array_split(results, f_total) np.savetxt(filename2+'_mean.txt', l)"""    determine freezing point"""data = np.loadtxt(filename2+'_mean.txt')# #   uncomment below to show std of drops against framescolor = mpl.cm.nipy_spectral(np.linspace(0, 1, d_total))mpl.rcParams['axes.prop_cycle'] = cycler('color', color)for column in data.T:  plt.scatter(x, column)plt.ylabel('Stdev of drop pixels')plt.xlabel('Frame number')plt.ion()plt.show()#   To sort when variation large at start of data set, assumes frame 0 is freezing point freezing_frame=[]for column in data.T:    a_prime = column[9:] - column[8:-1]    answer = np.argmax(np.abs(a_prime))    freezing_frame.append(answer+8) # +8 adjusts for missing framesprint(sorted(freezing_frame))freezing_frame = np.array(freezing_frame)  """    finally calculate temperature of freezing point and save as txt file"""#   load text filea = np.loadtxt(filename2+'.txt', skiprows=2)x = freezing_frame[0:]/5 # /5 refers to fpstemp = np.interp(x, a[:,0], a[:,2])np.savetxt(filename2+'_data.txt', temp)print(sorted(temp))